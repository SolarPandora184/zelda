<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Zelda Complex Clone</title>
  <style>
    body {
      margin: 0;
      background: #000;
      color: white;
      font-family: sans-serif;
      text-align: center;
    }
    canvas {
      display: block;
      margin: 0 auto;
      background-color: #1c1c1c;
      image-rendering: pixelated;
    }
  </style>
</head>
<body>
  <h1>Advanced Zelda-Like Game</h1>
  <canvas id="gameCanvas" width="640" height="480"></canvas>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const TILE_SIZE = 32;
    const MAP_ROWS = 15;
    const MAP_COLS = 20;
    const player = {
      x: 2,
      y: 2,
      width: TILE_SIZE,
      height: TILE_SIZE,
      color: 'lime',
      health: 5,
      attackTimer: 0,
    };

    const keys = {};
    const map = [
      "####################",
      "#.............H....#",
      "#.####.............#",
      "#......#####.......#",
      "#..............#####",
      "#.H..........#.....#",
      "#..........####....#",
      "#....E.............#",
      "#..........##......#",
      "#....#######.......#",
      "#...........#####..#",
      "#....H............E#",
      "#.........#####....#",
      "#...............#..#",
      "####################"
    ];

    const enemies = [];
    const items = [];

    function setupEntities() {
      for (let row = 0; row < MAP_ROWS; row++) {
        for (let col = 0; col < MAP_COLS; col++) {
          const tile = map[row][col];
          const x = col * TILE_SIZE;
          const y = row * TILE_SIZE;
          if (tile === 'E') {
            enemies.push({
              x,
              y,
              width: TILE_SIZE,
              height: TILE_SIZE,
              color: 'red',
              dx: Math.random() > 0.5 ? 1 : -1,
              dy: 0,
              speed: 1,
              patrol: 0,
              alive: true
            });
          } else if (tile === 'H') {
            items.push({
              x,
              y,
              width: TILE_SIZE / 2,
              height: TILE_SIZE / 2,
              color: 'pink',
              type: 'heart'
            });
          }
        }
      }
    }

    function drawRect(obj) {
      ctx.fillStyle = obj.color;
      ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
    }

    function tileAt(x, y) {
      const col = Math.floor(x / TILE_SIZE);
      const row = Math.floor(y / TILE_SIZE);
      return map[row]?.[col] || '#';
    }

    function isWalkable(x, y) {
      const tile = tileAt(x, y);
      return tile !== '#' && tile !== undefined;
    }

    function movePlayer() {
      let dx = 0, dy = 0;
      if (keys['ArrowUp']) dy = -1;
      if (keys['ArrowDown']) dy = 1;
      if (keys['ArrowLeft']) dx = -1;
      if (keys['ArrowRight']) dx = 1;

      const newX = player.x + dx * TILE_SIZE;
      const newY = player.y + dy * TILE_SIZE;

      if (isWalkable(newX, player.y)) player.x = newX;
      if (isWalkable(player.x, newY)) player.y = newY;
    }

    function updateEnemies() {
      for (const enemy of enemies) {
        if (!enemy.alive) continue;
        enemy.patrol++;
        if (enemy.patrol > 60) {
          enemy.dx *= -1;
          enemy.patrol = 0;
        }

        const newX = enemy.x + enemy.dx * enemy.speed;
        if (isWalkable(newX, enemy.y)) {
          enemy.x = newX;
        } else {
          enemy.dx *= -1;
        }

        // Collision with player
        if (
          enemy.alive &&
          rectsOverlap(enemy, player)
        ) {
          player.health -= 1;
          enemy.alive = false;
        }
      }
    }

    function updateItems() {
      for (const item of items) {
        if (rectsOverlap(item, player)) {
          if (item.type === 'heart') {
            player.health = Math.min(5, player.health + 1);
          }
          item.collected = true;
        }
      }
    }

    function rectsOverlap(a, b) {
      return (
        a.x < b.x + b.width &&
        a.x + a.width > b.x &&
        a.y < b.y + b.height &&
        a.y + a.height > b.y
      );
    }

    function attack() {
      if (player.attackTimer > 0) return;
      player.attackTimer = 20;

      const attackBox = {
        x: player.x,
        y: player.y - TILE_SIZE,
        width: TILE_SIZE,
        height: TILE_SIZE
      };

      for (const enemy of enemies) {
        if (enemy.alive && rectsOverlap(attackBox, enemy)) {
          enemy.alive = false;
        }
      }
    }

    function drawMap() {
      for (let row = 0; row < MAP_ROWS; row++) {
        for (let col = 0; col < MAP_COLS; col++) {
          const tile = map[row][col];
          if (tile === '#') {
            ctx.fillStyle = '#444';
            ctx.fillRect(col * TILE_SIZE, row * TILE_SIZE, TILE_SIZE, TILE_SIZE);
          }
        }
      }
    }

    function drawUI() {
      ctx.fillStyle = 'white';
      ctx.font = '16px sans-serif';
      ctx.fillText("Health: " + player.health, 10, 20);
    }

    function drawEntities() {
      drawRect(player);
      for (const enemy of enemies) {
        if (enemy.alive) drawRect(enemy);
      }
      for (const item of items) {
        if (!item.collected) drawRect(item);
      }
    }

    function gameLoop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawMap();
      movePlayer();
      updateEnemies();
      updateItems();

      if (player.attackTimer > 0) player.attackTimer--;
      drawEntities();
      drawUI();

      if (player.health <= 0) {
        ctx.fillStyle = 'red';
        ctx.font = '30px sans-serif';
        ctx.fillText("GAME OVER", canvas.width / 2 - 80, canvas.height / 2);
        return;
      }

      requestAnimationFrame(gameLoop);
    }

    // Controls
    window.addEventListener('keydown', e => {
      keys[e.key] = true;
      if (e.key === ' ') {
        attack();
      }
    });

    window.addEventListener('keyup', e => {
      keys[e.key] = false;
    });

    setupEntities();
    gameLoop();
  </script>
</body>
</html>
